<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="app-version" content="{{ app_version }}">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AudioMuse-AI - Database Cleaning</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="stylesheet" href="/static/menu.css">
    <style>
        .cleaning-summary {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }
        .active-button {
            background-color: #2563EB !important;
            border-color: #2563EB !important;
            color: white !important;
        }
        .active-button:hover {
            background-color: #1D4ED8 !important;
            border-color: #1D4ED8 !important;
        }
        .active-button:disabled {
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            cursor: not-allowed;
        }
        .danger-button {
            background-color: #dc3545 !important;
            border-color: #dc3545 !important;
            color: white !important;
        }
        .danger-button:hover {
            background-color: #c82333 !important;
            border-color: #bd2130 !important;
        }
        .danger-button:disabled {
            background-color: #6c757d !important;
            border-color: #6c757d !important;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="page-container">
        <aside class="sidebar">
            <nav>
                <ul class="sidebar-nav">
                    <!-- Menu items are dynamically inserted by menu.js -->
                </ul>
            </nav>
        </aside>

        <div class="main-content" id="main-content">
            <button class="menu-toggle">&#9776;</button>
            <div class="container">
                <div id="main-content-inner">
                    <section>
                        <div class="page-header">
                            <h1>Database Cleaning</h1>
                            <p class="subtitle">Automatically scan and clean orphaned albums from the database that no longer exist on the media server.</p>
                        </div>
                    </section>

                    <!-- Database Cleaning Section -->
                    <section id="cleaning-section">
                        <h2>Database Cleaning</h2>
                        <p>Run a scan to identify and automatically remove albums that exist in the database but are no longer present on your media server.</p>
                        
                        <div class="task-buttons">
                            <button id="start-clean-btn" class="active-button">Start Database Cleaning</button>
                            <button id="cancel-clean-btn" class="danger-button" style="display: none;" disabled>Cancel Cleaning</button>
                        </div>

                        <!-- Task Status Display -->
                        <div id="clean-status-display" style="display: none; margin-top: 1.5rem;">
                            <h3>Cleaning Status</h3>
                            <div id="task-status-display">
                                <p><span class="status-label">Task ID:</span> <span id="status-task-id">N/A</span></p>
                                <p><span class="status-label">Running Time:</span> <span id="status-running-time">-- : -- : --</span></p>
                                <p><span class="status-label">Status:</span> <span id="status-status">IDLE</span></p>
                                <p><span class="status-label">Progress:</span> <span id="status-progress">0</span>%</p>
                                <div class="progress-bar-container">
                                    <div id="progress-bar"></div>
                                </div>
                                <p><span class="status-label">Message:</span> <span id="status-message">N/A</span></p>
                                <div style="margin-top: 1rem;">
                                    <h4>Details / Log:</h4>
                                    <pre id="status-details"></pre>
                                </div>
                            </div>
                        </div>

                        <!-- Cleaning Results -->
                        <div id="cleaning-results" style="display: none; margin-top: 1.5rem;">
                            <h3>Cleaning Results</h3>
                            <div id="cleaning-summary" class="cleaning-summary">
                                <!-- Summary will be populated by JavaScript -->
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let currentTaskId = null;
        let cleanInterval = null;
        let startTime = null;

        // DOM elements
        const startCleanBtn = document.getElementById('start-clean-btn');
        const cancelCleanBtn = document.getElementById('cancel-clean-btn');
        const cleanStatusDisplay = document.getElementById('clean-status-display');
        const cleaningResults = document.getElementById('cleaning-results');

        // Initialize page - check for existing task
        document.addEventListener('DOMContentLoaded', function() {
            loadTaskStateFromStorage();
            checkForExistingTask();
        });

        // Event listeners
        startCleanBtn.addEventListener('click', startCleaning);
        cancelCleanBtn.addEventListener('click', cancelCleaning);

        // Save and load task state
        function saveTaskStateToStorage() {
            const state = {
                currentTaskId,
                startTime,
                cleanStatusVisible: cleanStatusDisplay.style.display !== 'none',
                resultsVisible: cleaningResults.style.display !== 'none'
            };
            localStorage.setItem('cleaningTaskState', JSON.stringify(state));
        }

        function loadTaskStateFromStorage() {
            const saved = localStorage.getItem('cleaningTaskState');
            if (saved) {
                try {
                    const state = JSON.parse(saved);
                    currentTaskId = state.currentTaskId;
                    startTime = state.startTime;
                    
                    if (state.cleanStatusVisible) {
                        cleanStatusDisplay.style.display = 'block';
                    }
                    if (state.resultsVisible) {
                        cleaningResults.style.display = 'block';
                    }
                } catch (e) {
                    console.error('Failed to load task state:', e);
                    localStorage.removeItem('cleaningTaskState');
                }
            }
        }

        function clearTaskStateFromStorage() {
            localStorage.removeItem('cleaningTaskState');
        }

        // Fetch and display last task status
        async function fetchAndDisplayLastTask() {
            try {
                const response = await fetch('/api/last_task');
                if (response.ok) {
                    const lastTask = await response.json();
                    if (lastTask && lastTask.task_id && lastTask.task_type === 'cleaning') {
                        displayTaskStatus(lastTask);
                        // If it was successful and has results, show them
                        if (['SUCCESS', 'FINISHED'].includes((lastTask.status || lastTask.state || '').toUpperCase()) && 
                            lastTask.details?.final_summary_details) {
                            displayCleaningResults(lastTask.details.final_summary_details);
                            cleaningResults.style.display = 'block';
                            saveTaskStateToStorage();
                        }
                    } else {
                        displayTaskStatus({ status: 'IDLE', details: { status_message: 'No previous cleaning task found.' } });
                    }
                } else {
                    displayTaskStatus({ status: 'IDLE', details: { status_message: 'Could not fetch last task status.' } });
                }
            } catch (error) {
                console.error('Error fetching last task status:', error);
                displayTaskStatus({ status: 'IDLE', details: { status_message: 'Error fetching last task status.' } });
            }
        }

        // Display task status
        function displayTaskStatus(task) {
            document.getElementById('status-task-id').textContent = task.task_id || 'N/A';
            document.getElementById('status-running-time').textContent = formatRunningTime(task.running_time_seconds);
            const stateUpper = (task.state || task.status || 'IDLE').toUpperCase();
            document.getElementById('status-status').textContent = stateUpper;
            document.getElementById('status-progress').textContent = task.progress || 0;
            document.getElementById('progress-bar').style.width = `${task.progress || 0}%`;
            
            let statusMessage = 'N/A';
            if (task.details) {
                if (task.details.status_message) {
                    statusMessage = task.details.status_message;
                } else if (Array.isArray(task.details.log) && task.details.log.length > 0) {
                    statusMessage = task.details.log[task.details.log.length - 1];
                }
                document.getElementById('status-details').textContent = JSON.stringify(task.details, null, 2);
            }
            document.getElementById('status-message').textContent = statusMessage;
        }

        // Format running time
        function formatRunningTime(seconds) {
            if (!seconds) return '-- : -- : --';
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours.toString().padStart(2, '0')} : ${minutes.toString().padStart(2, '0')} : ${secs.toString().padStart(2, '0')}`;
        }

        // Check for existing active task
        async function checkForExistingTask() {
            try {
                // First check for active tasks
                const activeResponse = await fetch('/api/active_tasks');
                if (activeResponse.ok) {
                    const activeData = await activeResponse.json();
                    if (activeData.task_id && activeData.task_type === 'cleaning' && 
                        ['STARTED', 'PROGRESS'].includes(activeData.status)) {
                        // Resume existing active task
                        currentTaskId = activeData.task_id;
                        startTime = Date.now() - (activeData.running_time_seconds * 1000);
                        
                        // Update UI to show active task
                        startCleanBtn.disabled = true;
                        cancelCleanBtn.style.display = 'inline-block';
                        cancelCleanBtn.disabled = false;
                        cleanStatusDisplay.style.display = 'block';
                        
                        document.getElementById('status-task-id').textContent = currentTaskId;
                        
                        // Start polling
                        pollTaskStatus();
                        
                        saveTaskStateToStorage();
                        return true; // Active task found
                    }
                }
                
                // If no active task, fetch and display last task
                await fetchAndDisplayLastTask();
                return false; // No active task
            } catch (error) {
                console.error('Error checking for existing task:', error);
                return false;
            }
        }

        // Start cleaning function
        async function startCleaning() {
            try {
                const response = await fetch('/api/cleaning/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                currentTaskId = data.task_id;
                
                // Update UI - disable start, enable cancel
                startCleanBtn.disabled = true;
                cancelCleanBtn.style.display = 'inline-block';
                cancelCleanBtn.disabled = false;
                cleanStatusDisplay.style.display = 'block';
                cleaningResults.style.display = 'none';
                
                document.getElementById('status-task-id').textContent = currentTaskId;
                startTime = Date.now();
                
                // Save state and start polling
                saveTaskStateToStorage();
                pollTaskStatus();
                
            } catch (error) {
                console.error('Error starting cleaning:', error);
                alert('Failed to start cleaning: ' + error.message);
            }
        }

        // Cancel cleaning function
        async function cancelCleaning() {
            if (!currentTaskId) return;
            
            try {
                await fetch(`/api/cancel/${currentTaskId}`, { method: 'POST' });
                resetUI();
                clearTaskStateFromStorage();
            } catch (error) {
                console.error('Error canceling cleaning:', error);
                alert('Failed to cancel cleaning: ' + error.message);
            }
        }

        // Poll task status - SAME PATTERN AS ANALYSIS PAGE
        function pollTaskStatus() {
            if (cleanInterval) clearInterval(cleanInterval);
            
            cleanInterval = setInterval(async () => {
                if (!currentTaskId) {
                    // FORCE STOP: If no current task, immediately clear interval and return
                    clearInterval(cleanInterval);
                    cleanInterval = null;
                    return;
                }
                
                try {
                    // POLL ACTIVE TASKS API LIKE ANALYSIS PAGE
                    const response = await fetch('/api/active_tasks');
                    if (!response.ok) {
                        console.log('Active tasks API returned error, stopping polling');
                        clearInterval(cleanInterval);
                        cleanInterval = null;
                        currentTaskId = null;
                        startTime = null;
                        resetCleaningUI();
                        return;
                    }
                    
                    const activeTask = await response.json();
                    
                    // Check if our task is still active
                    if (activeTask && activeTask.task_id === currentTaskId) {
                        // Task is still active, update status
                        updateTaskStatus(activeTask);
                        saveTaskStateToStorage();
                    } else {
                        // Task is no longer active - GET FINAL STATUS LIKE ANALYSIS PAGE
                        console.log(`Task ${currentTaskId} is no longer active - getting final status`);
                        
                        try {
                            const finalStatusResponse = await fetch(`/api/status/${currentTaskId}`);
                            if (finalStatusResponse.ok) {
                                const finalStatusData = await finalStatusResponse.json();
                                console.log('Final status received:', finalStatusData);
                                
                                // Update display with final status
                                updateTaskStatus(finalStatusData);
                                
                                // Handle completion based on final status
                                const finalStatus = (finalStatusData.state || finalStatusData.status || '').toUpperCase();
                                if (finalStatus === 'SUCCESS') {
                                    handleCleaningComplete(finalStatusData);
                                } else if (['FAILURE', 'REVOKED'].includes(finalStatus)) {
                                    handleCleaningError(finalStatusData);
                                } else {
                                    // Unknown final state, treat as completion
                                    handleCleaningComplete(finalStatusData);
                                }
                            } else {
                                console.log('Could not get final status, treating as completed');
                                handleCleaningComplete({ status: 'SUCCESS', task_id: currentTaskId });
                            }
                        } catch (e) {
                            console.error('Error getting final status:', e);
                            handleCleaningComplete({ status: 'SUCCESS', task_id: currentTaskId });
                        }
                        
                        // Clear polling regardless
                        clearInterval(cleanInterval);
                        cleanInterval = null;
                        clearTaskStateFromStorage();
                    }
                } catch (error) {
                    console.error('Error polling active tasks:', error);
                    // On error, also stop polling
                    clearInterval(cleanInterval);
                    cleanInterval = null;
                    currentTaskId = null;
                    startTime = null;
                    resetCleaningUI();
                }
            }, 2000);
        }

        // Update task status display
        function updateTaskStatus(data) {
            const stateUpper = (data.state || data.status || 'N/A').toUpperCase();
            document.getElementById('status-status').textContent = stateUpper;
            document.getElementById('status-progress').textContent = data.progress || 0;
            document.getElementById('progress-bar').style.width = `${data.progress || 0}%`;
            document.getElementById('status-message').textContent = data.details?.status_message || 'N/A';
            
            // Update running time ONLY if task is still running
            if (startTime && !['SUCCESS', 'FAILURE', 'REVOKED'].includes(stateUpper)) {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;
                document.getElementById('status-running-time').textContent = 
                    `${hours.toString().padStart(2, '0')} : ${minutes.toString().padStart(2, '0')} : ${seconds.toString().padStart(2, '0')}`;
            }
            
            // Update details - backend handles log truncation
            if (data.details) {
                document.getElementById('status-details').textContent = JSON.stringify(data.details, null, 2);
            }
        }

        // Handle cleaning completion
        function handleCleaningComplete(data) {
            console.log('Cleaning completed - STOPPING TIMER AND RESETTING UI');
            
            // FORCE STOP timer and polling
            if (cleanInterval) {
                clearInterval(cleanInterval);
                cleanInterval = null;
            }
            currentTaskId = null;
            startTime = null;
            
            // RESET UI BUTTONS immediately
            resetCleaningUI();
            
            const details = data.details?.final_summary_details;
            if (details) {
                console.log('Displaying cleaning results');
                displayCleaningResults(details);
                cleaningResults.style.display = 'block';
                saveTaskStateToStorage();
            } else {
                console.log('No cleaning results data found');
                alert('Cleaning completed but no results data found.');
            }
            
            // Also update the task status display
            displayTaskStatus(data);
        }

        // Handle cleaning error
        function handleCleaningError(data) {
            console.log('Cleaning error - STOPPING TIMER AND RESETTING UI');
            
            // FORCE STOP timer and polling
            if (cleanInterval) {
                clearInterval(cleanInterval);
                cleanInterval = null;
            }
            currentTaskId = null;
            startTime = null;
            
            // RESET UI BUTTONS immediately
            resetCleaningUI();
            
            alert(`Cleaning failed: ${data.details?.error_message || 'Unknown error'}`);
        }

        // Display cleaning results
        function displayCleaningResults(data) {
            const summaryDiv = document.getElementById('cleaning-summary');
            
            if (data.deleted_count > 0) {
                summaryDiv.innerHTML = `
                    <h3>✅ Database Cleaning Completed Successfully</h3>
                    <p><strong>Total albums on media server:</strong> ${data.total_media_server_albums}</p>
                    <p><strong>Total tracks on media server:</strong> ${data.total_media_server_tracks}</p>
                    <p><strong>Total tracks in database (before cleaning):</strong> ${data.total_database_tracks}</p>
                    <p><strong>Orphaned albums found:</strong> ${data.orphaned_albums_count}</p>
                    <p><strong>Orphaned tracks deleted:</strong> ${data.deleted_count}</p>
                    ${data.failed_deletions && data.failed_deletions.length > 0 ? 
                        `<p><strong>Failed deletions:</strong> ${data.failed_deletions.length}</p>` : ''}
                    <p style="color: #28a745; font-weight: bold;">Database cleaned successfully! ${data.deleted_count} orphaned tracks removed.</p>
                `;
            } else {
                summaryDiv.innerHTML = `
                    <h3>✅ Database is Clean</h3>
                    <p><strong>Total albums on media server:</strong> ${data.total_media_server_albums}</p>
                    <p><strong>Total tracks on media server:</strong> ${data.total_media_server_tracks}</p>
                    <p><strong>Total tracks in database:</strong> ${data.total_database_tracks}</p>
                    <p style="color: #28a745; font-weight: bold;">No orphaned tracks found. Your database is already clean!</p>
                `;
            }
        }

        // Reset UI functions
        function resetCleaningUI() {
            startCleanBtn.disabled = false;
            cancelCleanBtn.style.display = 'none';
            cancelCleanBtn.disabled = true;
        }

        function resetUI() {
            resetCleaningUI();
            if (cleanInterval) {
                clearInterval(cleanInterval);
                cleanInterval = null;
            }
            currentTaskId = null;
            startTime = null;
            cleanStatusDisplay.style.display = 'none';
            cleaningResults.style.display = 'none';
            console.log('UI completely reset - all timers and intervals cleared');
        }
    </script>
    <script src="/static/menu.js"></script>
</body>
</html>